# описание алгоритма

Пока что реализовал только передачу и прием информации о положении водителей. Нужно доделать добавление на карту различных иконок: гаишники, аварии и т.д.
Кстати, тоже интересная задача)) уже придумал как это делать

основные файлы для органиазции взаимодействия водителя с сервером:

- connected_drivers_base.go из пакета internal/base
- start.go из пакета drivers/handlers

# Начало работы

Сервер создает в памяти базу для хранения подключенных к серверу водителей. Водитель считается подключенным если с ним поддерживается соединение.
данные о водителях в базе хранятся в виде map: *map[uuid.UUID]*ConnectedDriver

```
connectedDriversBase, err := base.CreateConnectedDriversBase(s.logger)
```

Т.к. эта база не является ни агрегатом, ни репозиторием, я не знал куда сохранять ее код. Поэтому сохранил в пакет internal/base

Далее сервер запускает горутину для обеспечения работы этой базы.

```
go connectedDriversBase.HandleBase()
```

эта горутина через заданные промежутки времени составляет строку данных с координатами всех водителей и рассылает эту строку всем водителям

```
// отсылаем данные всем водителями
case <-ticker.C:
	b.broadcastDataToAllDrivers()
```

Также эта горутина через канал ReceiveDataFromDriverCH получает данные от водителей. Данные приходят в виде структуры ConnectedDriver.

```
// обновляем данные водителя в базе. Если его там нет, то добавляем
case connectedDriver := <-b.ReceiveDataFromDriverCH:
	b.updateDriversData(connectedDriver)
```

последнее что делает эта горутина - обрабатывает сигнал через канал RemoveDriverCH. Через этот канал поступает id удаляемого из базы водителя
пока что это закоменчено. Нужно это для того, чтобы водитель через приложение мог послать сигнал о завершении работы. Не знаю нужно это или нет.
Т.е. водитель хочет завершить работу. Жмет у себя кнопку закрыть приложение (ну или отключиться) - вот в этом слугае от него и идет такой сигнал.

```
// удаляем неактивного водителя из базы
case driverID := <-b.RemoveDriverCH:
	b.removeDriverFromBase(driverID)
```

# логика подключения водителя к серверу

хэндлер drivers/handlers/start.go отвечает за соединение с водителем.
Для создания соединения использую пакет "github.com/gorilla/websocket"

когда водитель авторизовался, то для начала работы ему нужно обратиться к хэндлеру Start().
Этот хэндлер проверяет - был ли сегодняшний день уже оплачен водителем. Т.к. водитель мог оплатить работу, а потом отключиться.
После повторного подключения он должен продолжить работу без списания средств с баланса.
Если же оплаты еще не было, то нужно проверить - достаточно ли у него средств на балансе.
Получение стоимости работы одного дня пока что реализовано как заглушка и возвращает фиксированное значение.
Если средств достаточно, то происодит списание средств и подключение водителя к серверу.

# работа с каналами

Водитель взаимодействует с базой через каналы.

у базы есть канал для получения данных от всех водителей - ReceiveDataFromDriverCH.
горутина readDataFromDriver, которая ждет информацию через сокет, отправляет полученные данные в этот канал.
посылать отдельный сигнал на закрытие этой горутины не нужно, т.к. при зкрытии сокета в ней возникнет ошибка и она закроется сама.

У водителя есть канал для получения данных из базы - SendDataToDriverCH.
База через заданные промежутки времени отправляет данные в этот канал.

У водителя есть канал для передачи сигнала о закрытии сокета - DoneCH.
Когда нужно закрыть соединение, база закрывает этот канал

# Создание соединения и взаимодействие с сервером

После создания сокета, запускается горутина для получения данных из него

```
// читаем данные от водителя
// горутина будет закрываться при закрытии websocket
go readDataFromDriver(conn, h.logger, &connectedDriver, h.connectedDriversBase.ReceiveDataFromDriverCH)
```

затем мы ждем сигнала о закрытии сокета

```
// здесь нужен бесконечный цикл, т.к. при завершении функции, websocket закрывается
// но нам нужен сигнал о том, что мы действительно хотим закрыть сокет
// поэтому ждем этот сигнал чеерез канал водителя
for {
	select {
	case <-connectedDriver.DoneCH: // закрытие канала done
		h.logger.Info("Close websocket")
		return
	}
}
```

```

```

```

```

```

```
